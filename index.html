<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Frontline: Territorial Push</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --grass: #354a21;
            --player-zone: rgba(116, 185, 255, 0.2);
            --enemy-zone: rgba(255, 118, 117, 0.2);
        }
        body { margin: 0; background: #1a1a1a; color: white; font-family: sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        .header { height: 50px; background: #000; display: flex; justify-content: space-around; align-items: center; border-bottom: 2px solid #444; }
        canvas { flex-grow: 1; background: var(--grass); display: block; }
        .controls { height: 100px; background: #111; display: flex; justify-content: center; gap: 20px; align-items: center; }
        .btn { width: 80px; height: 70px; background: #222; border: 1px solid #555; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; }
        .btn:active { background: #444; }
        .val { color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <div class="header">
        <div>SCRAP: <span class="val" id="scrap">100</span></div>
        <div>PARTS: <span class="val" id="parts">0</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="controls">
        <div class="btn" onclick="spawn('infantry')"><b>INF</b><span>10</span></div>
        <div class="btn" onclick="spawn('tank')"><b>TANK</b><span>40</span></div>
        <div id="aiBtn" class="btn" onclick="toggleAI()" style="border-color: #27ae60;"><b>AUTO</b><span id="aiStatus">OFF</span></div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let scrap = 100;
    let parts = 0;
    let isAI = false;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 150;
    }
    window.onresize = resize;
    resize();

    const segmentCount = 15; // Больше сегментов для плавности
    let frontlineY = Array(segmentCount + 1).fill(canvas.height / 2);
    let units = [];
    let projectiles = [];

    class Unit {
        constructor(side, type) {
            this.side = side;
            this.type = type;
            this.x = canvas.width / 2 + (Math.random() * 60 - 30);
            this.y = side === 'player' ? canvas.height - 30 : 30;
            this.targetX = Math.random() * canvas.width;
            this.hp = type === 'infantry' ? 50 : 250;
            this.currentHp = this.hp;
            this.speed = type === 'infantry' ? 1.2 : 0.6;
            this.range = type === 'infantry' ? 80 : 130;
            this.damage = type === 'infantry' ? 5 : 15;
            this.size = type === 'infantry' ? 5 : 12;
        }

        update() {
            let segIndex = Math.floor((this.x / canvas.width) * segmentCount);
            segIndex = Math.max(0, Math.min(segmentCount, segIndex));
            let currentLineY = frontlineY[segIndex];

            // Проверка: находится ли юнит у линии фронта
            let atFront = (this.side === 'player' && this.y <= currentLineY + 5) || 
                          (this.side === 'enemy' && this.y >= currentLineY - 5);

            // Поиск врага
            let enemies = units.filter(u => u.side !== this.side);
            let target = null;
            for(let e of enemies) {
                let d = Math.hypot(this.x - e.x, this.y - e.y);
                if(d < this.range) { target = e; break; }
            }

            // Движение
            if (!atFront || target) {
                // Если не у фронта — идем к нему
                let angle = Math.atan2((this.side === 'player' ? -1 : 1), (this.targetX - this.x) / 150);
                this.x += Math.cos(angle) * this.speed * 0.5;
                this.y += Math.sin(angle) * (target ? this.speed * 0.2 : this.speed);
            } else {
                // Если у фронта и нет врага — толкаем линию!
                if(this.side === 'player' && frontlineY[segIndex] > 50) {
                    frontlineY[segIndex] -= (this.type === 'tank' ? 0.3 : 0.1);
                    this.y = frontlineY[segIndex] + 2; // Прилипаем к линии
                } else if(this.side === 'enemy' && frontlineY[segIndex] < canvas.height - 50) {
                    frontlineY[segIndex] += (this.type === 'tank' ? 0.3 : 0.1);
                    this.y = frontlineY[segIndex] - 2;
                }
            }

            // Стрельба
            if(target && Math.random() < 0.05) {
                projectiles.push({x: this.x, y: this.y, tx: target.x, ty: target.y, side: this.side});
                target.currentHp -= this.damage / 10;
            }

            // Интеллектуальное перестроение (ищем, где линия провалена)
            if(Math.random() < 0.01) {
                let worstSeg = 0;
                let worstVal = this.side === 'player' ? -1 : 9999;
                for(let i=0; i<segmentCount; i++) {
                    if(this.side === 'player' && frontlineY[i] > worstVal) { worstVal = frontlineY[i]; worstSeg = i; }
                    if(this.side === 'enemy' && frontlineY[i] < worstVal) { worstVal = frontlineY[i]; worstSeg = i; }
                }
                this.targetX = (worstSeg * (canvas.width / segmentCount)) + (canvas.width / segmentCount / 2);
            }

            return this.currentHp <= 0;
        }

        draw() {
            ctx.fillStyle = this.side === 'player' ? '#74b9ff' : '#ff7675';
            ctx.beginPath();
            if(this.type === 'infantry') ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            else ctx.fillRect(this.x - this.size, this.y - this.size/2, this.size*2, this.size);
            ctx.fill();
            
            // Полоска здоровья
            ctx.fillStyle = 'red';
            ctx.fillRect(this.x - 10, this.y - 15, 20, 2);
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(this.x - 10, this.y - 15, (this.currentHp/this.hp)*20, 2);
        }
    }

    function spawn(type, side='player') {
        let cost = type === 'infantry' ? 10 : 40;
        if(side === 'player') { if(scrap < cost) return; scrap -= cost; }
        units.push(new Unit(side, type));
    }

    function toggleAI() { isAI = !isAI; document.getElementById('aiStatus').innerText = isAI ? "ON" : "OFF"; }

    setInterval(() => {
        spawn(Math.random() > 0.7 ? 'tank' : 'infantry', 'enemy');
        if(isAI && scrap >= 10) spawn(scrap > 50 ? 'tank' : 'infantry', 'player');
    }, 2500);

    function gameLoop() {
        ctx.fillStyle = '#354a21'; // Темная трава
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Отрисовка зон контроля
        ctx.fillStyle = 'rgba(116, 185, 255, 0.1)'; // Игрок
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for(let i=0; i<=segmentCount; i++) ctx.lineTo(i*(canvas.width/segmentCount), frontlineY[i]);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.fill();

        // Линия фронта (белый пунктир)
        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(0, frontlineY[0]);
        for(let i=1; i<=segmentCount; i++) ctx.lineTo(i*(canvas.width/segmentCount), frontlineY[i]);
        ctx.stroke();
        ctx.setLineDash([]);

        units = units.filter(u => {
            let dead = u.update();
            if(dead && u.side === 'enemy' && Math.random() < 0.25) parts++;
            u.draw();
            return !dead;
        });

        projectiles = projectiles.filter(p => {
            ctx.strokeStyle = p.side === 'player' ? '#f1c40f' : '#fff';
            ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.tx, p.ty); ctx.stroke();
            return false;
        });

        document.getElementById('scrap').innerText = Math.floor(scrap += 0.07);
        document.getElementById('parts').innerText = parts;
        requestAnimationFrame(gameLoop);
    }
    gameLoop();
</script>
</body>
</html>
